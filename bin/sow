#!/usr/bin/env ruby

require 'clio/usage'
require 'sow/manager'

use = Clio::Usage.new
use['--skip   -s', 'skip  overwrites']
use['--force  -f', 'force overwrites']
use['--prompt -p', 'prompt on overwrites']
use['--delete'   , 'remove scaffolding previously created']
use['--trial'    , 'trial run (does not actually copy any files)']
use['--debug'    , 'debug execution']
use['--help'     , 'display this help information']
use['--output=PATH -o', 'output directory']
#use['<TYPE>', 'scaffolding type']

manager = Sow::Manager.new

manager.plugins.each do |type|
  use.command(type) #['<*ARGS>']
end

#name = ARGV.find{ |a| a !~ /^-/ }  # <- FIXME: use this instead

# preparse to get scaffold name
cli = use.parse(ARGV)
name      = cli.command
arguments = cli.arguments.dup
options   = cli.options.dup

# TODO: It sucks that we have to parse the commandline twice
# and create the plugin twice to expidite usage help.
# figure out a work around.

if name
  plugin = manager.plugin(name, arguments, options)
  manifest = plugin.manifest
  #manifest = manager.plugin_manifest(name)  # <- FIXME: use this instead
  manifest.arguments.each do |a, b|
    use.command(name).argument(a)
  end
  manifest.options.each do |o, b|
    use.command(name).option(o).arg('VALUE')
  end
  if cli.help?
    puts use.command(name).help.to_s(:bold=>true)
    exit
  end
else
  if cli.help?
    puts use.help.to_s(:bold=>true)
    exit
  else
    puts "scaffold name required"
    exit
  end
end

# secondary parse to get subcommand options
cli = use.parse(ARGV)
name      = cli.command
arguments = cli.arguments.dup
options   = cli.options.dup

plugin = manager.plugin(name, arguments, options)

begin
  if cli.delete?
    plugin.delete
  else
    plugin.create
  end
rescue => err
  if cli.debug?
    raise err
  else
    puts err
    puts "try --help or --debug"
    exit
  end
end




=begin
    attr :cmd
    attr :args
    attr :opts

    #
    def initialize(argv=ARGV)
      cli = Argvector.new(argv)

      @cmd, @args, @opts = *cli.subcommand

      #@use['--help -h', "Display this help infromation"]

      #@use['--create -c', "Create scaffolding (default)"]
      #@use['--update -u', "Update scaffolding (default)"]
      #@use['--delete -d', "Delete scaffolding (default)"]

      #@use['--output=PATH -o', "Output directory [.]"]

      #manager.plugins.each do |name|
      #  @use.subcommand(name)
      #end
    end

    #
    def manager
      @manager ||= Manager.new
    end

    #
    def run
      name = cmd

      if opts['help'] || opts['h']
        if name
          puts "help to do #{name}"
        else
          puts "help to do"
        end
        exit
      end

      del = opts['d'] || opts['delete']

      unless name
        puts "Scaffold name required."
        exit
      end

      command = del ? :delete : :create
      arguments = [name]

      begin
        send(command, *arguments)
      rescue => err
        if cli.debug?
          raise err
        else
          puts err
          puts "try --help or --debug"
          exit
        end
      end

    end

    def create(name)
      plugin = manager.plugin(name, @args, @opts.dup)
      plugin.create
    end

    def delete(name)
      plugin = manager.plugin(name, @args, @opts.dup)
      plugin.delete
    end

    def trace?
      @opts['trace']
    end

=end

